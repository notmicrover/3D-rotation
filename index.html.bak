<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Cube Â· Material & Recording</title>
    <style>
        /* å®Œæ•´æ ·å¼ï¼ˆä¸ä¹‹å‰ä¸€è‡´ï¼Œå·²åŒ…å«æ‰€æœ‰æ§ä»¶æ ·å¼ï¼ŒåŒ…æ‹¬æ–°å¢çš„ ConvertHub åŒºåŸŸï¼‰ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0e121f;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            padding: 1rem;
        }
        .canvas-wrapper {
            width: 600px;
            max-width: 90vw;
            aspect-ratio: 1 / 1;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 30px 40px rgba(0, 0, 0, 0.8), 0 0 0 2px #3a4568 inset;
            margin-bottom: 1.5rem;
            background: #101624;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .control-panel {
            background: rgba(18, 24, 38, 0.95);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 40px;
            padding: 2rem;
            border: 1px solid #4d5f8a;
            box-shadow: 0 25px 40px -5px black;
            width: min(1150px, 100%);
            color: #eef3ff;
            max-height: 70vh;
            overflow-y: auto;
        }
        .lang-switch {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .lang-btn {
            background: #2c3b68;
            border: 1.5px solid #8ba2ee;
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 40px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }
        .lang-btn.active {
            background: #4f69b0;
            border-color: #c6d6ff;
        }
        .section-title {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #9db4f0;
            margin: 1.5rem 0 1rem 0;
            border-left: 4px solid #7994e0;
            padding-left: 1rem;
        }
        .flex-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 1.5rem;
            background: #1c2542;
            padding: 1rem 2rem;
            border-radius: 60px;
            margin-bottom: 1.5rem;
        }
        .param-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        .param-item label {
            font-weight: 500;
            color: #bdcbff;
            min-width: 40px;
        }
        .param-item input[type="number"] {
            width: 70px;
            background: #0e162f;
            border: 1px solid #5f74b0;
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 30px;
            font-weight: 600;
            text-align: center;
        }
        .param-item input[type="range"] {
            width: 180px;
        }
        .param-item select {
            background: #0e162f;
            color: white;
            border: 1px solid #5f74b0;
            border-radius: 30px;
            padding: 0.4rem 1rem;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .param-item input[type="text"] {
            width: 220px;
            background: #0e162f;
            border: 1px solid #5f74b0;
            color: white;
            padding: 0.4rem 1rem;
            border-radius: 30px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .checkbox-item input {
            width: 18px;
            height: 18px;
            accent-color: #6f8cff;
        }
        .record-btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0 1rem;
        }
        .record-btn {
            background: #2c3b68;
            border: 1.5px solid #8ba2ee;
            color: white;
            padding: 0.9rem 2rem;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 8px 16px #00000080;
            min-width: 160px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .record-btn.webm { background: #2b4970; }
        .record-btn.mp4 { background: #2c3b68; }
        .record-btn.gif { background: #452d63; }
        .record-btn:hover { background: #4f69b0; border-color: #c6d6ff; }
        .footer-note {
            text-align: center;
            color: #7a8bbf;
            font-size: 0.75rem;
            margin-top: 1.5rem;
        }
        .repo-link {
            text-align: center;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .repo-link a {
            color: #9db4f0;
            text-decoration: none;
            font-size: 0.85rem;
            border-bottom: 1px dotted #5f74b0;
            transition: color 0.2s;
        }
        .repo-link a:hover {
            color: #c6d6ff;
            border-bottom-color: #c6d6ff;
        }
        .hidden-input { display: none; }
        .collapse-section {
            background: #1b2340;
            border-radius: 40px;
            padding: 1.5rem 2rem;
            margin-top: 1.5rem;
        }
        .collapse-toggle {
            color: #b4c7ff;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            font-size: 1rem;
            display: inline-block;
            margin-bottom: 1rem;
            background: #2f3d66;
            padding: 0.3rem 1.5rem;
            border-radius: 40px;
        }
        .oneclick-row {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 1.5rem;
            background: #262f55;
            padding: 1rem 2rem;
            border-radius: 60px;
            margin-bottom: 1.5rem;
        }
        .oneclick-btn {
            background: #4f68b0;
            border: none;
            color: white;
            padding: 0.6rem 2rem;
            border-radius: 40px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: 0.15s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .oneclick-btn:hover { background: #6f8cff; }
        .face-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .face-card {
            background: #111a33;
            border-radius: 24px;
            padding: 0.8rem;
            border: 1px solid #435785;
            text-align: center;
        }
        .face-preview {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 16px;
            margin: 8px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #1f2b4f;
        }
        .face-preview img {
            max-width: 100%;
            max-height: 100%;
            display: none;
        }
        .btn-upload, .btn-clear {
            width: 100%;
            padding: 6px;
            border-radius: 30px;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
            margin: 2px 0;
        }
        .btn-upload { background: #314682; }
        .btn-clear { background: #2c365a; color: #ccd6ff; }
    </style>
    <!-- ä½¿ç”¨å…¨å±€ Three.js å’Œ GIF.js -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
</head>
<body>
    <div class="canvas-wrapper">
        <canvas id="threeCanvas"></canvas>
    </div>

    <div class="control-panel">
        <!-- è¯­è¨€åˆ‡æ¢æŒ‰é’® -->
        <div class="lang-switch">
            <div class="lang-btn" id="langZhBtn">ä¸­æ–‡</div>
            <div class="lang-btn" id="langEnBtn">English</div>
        </div>

        <!-- å½•åˆ¶å‚æ•° -->
        <div class="section-title" data-i18n="recordingParams">âš™ï¸ å½•åˆ¶å‚æ•°</div>
        <div class="flex-row">
            <div class="param-item">
                <label data-i18n="fps">å¸§ç‡</label>
                <input type="number" id="fpsInput" min="1" max="60" value="24" step="1">
            </div>
            <div class="param-item">
                <label data-i18n="duration">æ—¶é•¿(s)</label>
                <input type="number" id="durationInput" min="0.5" max="30" value="5" step="0.5">
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="transparentBgCheckbox">
                <label data-i18n="transparentBg">é€æ˜èƒŒæ™¯ (éšè—æ˜Ÿç©º/çº¯èƒŒæ™¯)</label>
            </div>
        </div>

        <!-- è½¬é€Ÿ + èƒŒæ™¯è‰² -->
        <div class="flex-row" style="justify-content: space-between;">
            <div class="param-item">
                <label data-i18n="speed">è½¬é€Ÿ</label>
                <input type="range" id="speedSlider" min="0" max="0.02" step="0.0005" value="0.008">
                <span id="speedValue">0.0080</span>
            </div>
            <div class="param-item">
                <label data-i18n="bgColor">èƒŒæ™¯è‰²</label>
                <input type="color" id="bgColorPicker" value="#131725">
            </div>
        </div>

        <!-- å½•åˆ¶æŒ‰é’®ç»„ -->
        <div class="record-btn-group">
            <div class="record-btn webm" id="recordWebmBtn" data-i18n="recordWebm">ğŸ¬ å½•åˆ¶ WebM</div>
            <div class="record-btn mp4" id="recordMp4Btn" data-i18n="recordMp4">ğŸ¥ å½•åˆ¶ MP4</div>
            <div class="record-btn gif" id="recordGifBtn" data-i18n="recordGif">ğŸ“¹ å½•åˆ¶ GIF (æœ¬åœ°)</div>
        </div>

        <!-- ConvertHub GIF å½•åˆ¶åŒºåŸŸï¼ˆæ–°å¢ï¼‰ -->
        <div class="flex-row" style="justify-content: space-between; margin-top: 1rem;">
            <div class="param-item" style="flex-grow: 1;">
                <label data-i18n="convertHubApiKey">ConvertHub API Key</label>
                <input type="text" id="convertHubApiKey" placeholder="Enter your API key" style="width: 220px;">
                <a href="https://converthub.com/register" target="_blank" data-i18n="getApiKey">[Get Key]</a>
            </div>
            <div class="record-btn gif" id="recordGifConvertHub" data-i18n="recordGifConvertHub">ğŸï¸ GIF (ConvertHub)</div>
        </div>

        <!-- æè´¨é«˜çº§é¢æ¿ï¼ˆä¿æŒä¸å˜ï¼‰ -->
        <div class="collapse-section">
            <div class="collapse-toggle" onclick="document.getElementById('facePanel').style.display = document.getElementById('facePanel').style.display === 'none' ? 'grid' : 'none'" data-i18n="toggleMaterial">â–¼ æè´¨è‡ªå®šä¹‰ (ç‚¹å‡»å±•å¼€/æŠ˜å )</div>
            
            <!-- çº¹ç†æ¨¡å¼é€‰æ‹© -->
            <div class="flex-row" style="justify-content: flex-start;">
                <div class="param-item">
                    <label data-i18n="textureMode">è´´å›¾æ¨¡å¼</label>
                    <select id="textureModeSelect">
                        <option value="stretch" data-i18n-option="stretch" selected>æ‹‰ä¼¸</option>
                        <option value="fit" data-i18n-option="fit">é€‚åº”</option>
                        <option value="cover" data-i18n-option="cover">å¡«å……</option>
                        <option value="none" data-i18n-option="none">æ— æ“ä½œ</option>
                    </select>
                </div>
            </div>

            <!-- ä¸€é”®æ›¿æ¢æ‰€æœ‰é¢ -->
            <div class="oneclick-row">
                <div class="oneclick-btn" id="oneClickUploadBtn" data-i18n="oneClickUpload">ğŸ–¼ï¸ ä¸€é”®æ›¿æ¢æ‰€æœ‰é¢æè´¨</div>
                <span data-i18n="oneClickHint">ä¸Šä¼ ä¸€å¼ å›¾åº”ç”¨åˆ°å…­ä¸ªé¢</span>
            </div>
            <!-- å…­é¢ç½‘æ ¼ -->
            <div id="facePanel" class="face-grid" style="display: grid;"></div>
        </div>

        <div class="footer-note" data-i18n="footerNote">é€æ˜èƒŒæ™¯å°†éšè—æ˜Ÿç©ºç²’å­ï¼Œä»…ä¿ç•™ç«‹æ–¹ä½“ã€‚å½•åˆ¶GIFå»ºè®®å¸§ç‡â‰¤24ã€‚</div>
        
        <!-- ä»“åº“é“¾æ¥ -->
        <div class="repo-link">
            <a href="https://github.com/notmicrover/3D-rotation" target="_blank" rel="noopener noreferrer" data-i18n="repoLink">GitHub Repository</a>
        </div>
    </div>

    <script>
        // --- è¯­è¨€åŒ… (æ–°å¢å­—æ®µ) ---
        const i18n = {
            en: {
                title: '3D Cube Â· Material & Recording',
                recordingParams: 'âš™ï¸ Recording Parameters',
                fps: 'FPS',
                duration: 'Dur (s)',
                transparentBg: 'Transparent BG (hide stars)',
                speed: 'Speed',
                bgColor: 'BG Color',
                recordWebm: 'ğŸ¬ Record WebM',
                recordMp4: 'ğŸ¥ Record MP4',
                recordGif: 'ğŸ“¹ Record GIF (local)',
                recordGifConvertHub: 'ğŸï¸ GIF (ConvertHub)',
                convertHubApiKey: 'ConvertHub API Key',
                getApiKey: '[Get Key]',
                toggleMaterial: 'â–¼ Material Settings (click to expand/collapse)',
                textureMode: 'Texture Mode',
                stretch: 'Stretch',
                fit: 'Fit',
                cover: 'Cover',
                none: 'None',
                oneClickUpload: 'ğŸ–¼ï¸ Oneâ€‘Click Replace All Faces',
                oneClickHint: 'Upload one image for all six faces',
                footerNote: 'Transparent background hides stars, only cube remains. For GIF, keep FPS â‰¤ 24.',
                upload: 'Upload',
                clear: 'Reset',
                repoLink: 'GitHub Repository',
                faceNames: ['Front', 'Back', 'Left', 'Right', 'Top', 'Bottom']
            },
            zh: {
                title: '3Dç«‹æ–¹ä½“ Â· ä¸€é”®æè´¨/é€æ˜èƒŒæ™¯/ä¸“ä¸šå½•åˆ¶',
                recordingParams: 'âš™ï¸ å½•åˆ¶å‚æ•°',
                fps: 'å¸§ç‡',
                duration: 'æ—¶é•¿(s)',
                transparentBg: 'é€æ˜èƒŒæ™¯ (éšè—æ˜Ÿç©º/çº¯èƒŒæ™¯)',
                speed: 'è½¬é€Ÿ',
                bgColor: 'èƒŒæ™¯è‰²',
                recordWebm: 'ğŸ¬ å½•åˆ¶ WebM',
                recordMp4: 'ğŸ¥ å½•åˆ¶ MP4',
                recordGif: 'ğŸ“¹ å½•åˆ¶ GIF (æœ¬åœ°)',
                recordGifConvertHub: 'ğŸï¸ GIF (ConvertHub)',
                convertHubApiKey: 'ConvertHub API å¯†é’¥',
                getApiKey: '[è·å–å¯†é’¥]',
                toggleMaterial: 'â–¼ æè´¨è‡ªå®šä¹‰ (ç‚¹å‡»å±•å¼€/æŠ˜å )',
                textureMode: 'è´´å›¾æ¨¡å¼',
                stretch: 'æ‹‰ä¼¸',
                fit: 'é€‚åº”',
                cover: 'å¡«å……',
                none: 'æ— æ“ä½œ',
                oneClickUpload: 'ğŸ–¼ï¸ ä¸€é”®æ›¿æ¢æ‰€æœ‰é¢æè´¨',
                oneClickHint: 'ä¸Šä¼ ä¸€å¼ å›¾åº”ç”¨åˆ°å…­ä¸ªé¢',
                footerNote: 'é€æ˜èƒŒæ™¯å°†éšè—æ˜Ÿç©ºç²’å­ï¼Œä»…ä¿ç•™ç«‹æ–¹ä½“ã€‚å½•åˆ¶GIFå»ºè®®å¸§ç‡â‰¤24ã€‚',
                upload: 'ä¸Šä¼ ',
                clear: 'æ¢å¤',
                repoLink: 'GitHub ä»“åº“',
                faceNames: ['å‰', 'å', 'å·¦', 'å³', 'ä¸Š', 'ä¸‹']
            }
        };

        let currentLang = 'en';

        function setLanguage(lang) {
            currentLang = lang;
            document.title = i18n[lang].title;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (i18n[lang][key]) {
                    el.innerText = i18n[lang][key];
                }
            });
            document.querySelectorAll('[data-i18n-option]').forEach(el => {
                const key = el.getAttribute('data-i18n-option');
                if (i18n[lang][key]) {
                    el.innerText = i18n[lang][key];
                }
            });
            document.querySelectorAll('.face-card .face-name').forEach((el, index) => {
                if (el && index < 6) {
                    el.innerText = i18n[lang].faceNames[index];
                }
            });
            document.getElementById('langZhBtn').classList.toggle('active', lang === 'zh');
            document.getElementById('langEnBtn').classList.toggle('active', lang === 'en');
        }

        // --- åˆå§‹åŒ–åœºæ™¯ (Three.js) ä¸ä¹‹å‰å®Œå…¨ä¸€è‡´ ---
        (function init() {
            const canvas = document.getElementById('threeCanvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }

            const renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true, 
                preserveDrawingBuffer: true,
                alpha: true 
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x131725, 1);

            const scene = new THREE.Scene();
            scene.background = null;

            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            camera.position.set(2.5, 1.8, 3.5);
            camera.lookAt(0, 0, 0);

            const ambient = new THREE.AmbientLight(0x40486a);
            scene.add(ambient);
            const light1 = new THREE.PointLight(0xffeedd, 1.2);
            light1.position.set(3, 5, 5);
            scene.add(light1);
            const light2 = new THREE.PointLight(0xaaccff, 1.0);
            light2.position.set(-4, 2, 4);
            scene.add(light2);

            const starsGeo = new THREE.BufferGeometry();
            const starsPos = new Float32Array(900 * 3);
            for (let i = 0; i < starsPos.length; i+=3) {
                starsPos[i] = (Math.random()-0.5)*40;
                starsPos[i+1] = (Math.random()-0.5)*40;
                starsPos[i+2] = (Math.random()-0.5)*40;
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
            const starsMat = new THREE.PointsMaterial({ color: 0xa5b9f0, size: 0.06 });
            const stars = new THREE.Points(starsGeo, starsMat);
            scene.add(stars);

            const initColors = [0xff5e5e, 0x5f8cff, 0x5eff8c, 0xffcd5e, 0xca7dff, 0xff8fc7];
            const materials = initColors.map(hex => new THREE.MeshStandardMaterial({ color: hex, roughness: 0.3, metalness: 0.1 }));
            const geometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const cube = new THREE.Mesh(geometry, materials);
            scene.add(cube);

            let speed = 0.008;
            const speedSlider = document.getElementById('speedSlider');
            const speedSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', e => {
                speed = parseFloat(e.target.value);
                speedSpan.textContent = speed.toFixed(4);
            });

            const bgPicker = document.getElementById('bgColorPicker');
            const transparentCheck = document.getElementById('transparentBgCheckbox');
            
            bgPicker.addEventListener('input', e => {
                const val = e.target.value;
                const transparent = transparentCheck.checked;
                renderer.setClearColor(parseInt(val.slice(1), 16), transparent ? 0 : 1);
            });

            transparentCheck.addEventListener('change', e => {
                const checked = e.target.checked;
                const currentColor = bgPicker.value;
                const colorInt = parseInt(currentColor.slice(1), 16);
                renderer.setClearColor(colorInt, checked ? 0 : 1);
                stars.visible = !checked;
            });

            function animate() {
                requestAnimationFrame(animate);
                cube.rotation.y += speed;
                stars.rotation.y += 0.0002;
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const w = canvas.clientWidth;
                const h = canvas.clientHeight;
                renderer.setSize(w, h, false);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            });

            // --- çº¹ç†æ¨¡å¼ç›¸å…³ (ä¿æŒä¸å˜) ---
            const textureModeSelect = document.getElementById('textureModeSelect');
            function getCurrentTextureMode() {
                return textureModeSelect.value;
            }

            const faceOriginalDataURLs = Array(6).fill(null);

            function generateTextureFromImage(dataURL, mode) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        const size = 512;
                        canvas.width = size;
                        canvas.height = size;
                        ctx.clearRect(0, 0, size, size);

                        const imgW = img.width;
                        const imgH = img.height;
                        const imgAspect = imgW / imgH;

                        switch (mode) {
                            case 'stretch':
                                ctx.drawImage(img, 0, 0, size, size);
                                break;
                            case 'fit':
                                if (imgAspect > 1) {
                                    const drawH = size / imgAspect;
                                    const drawY = (size - drawH) / 2;
                                    ctx.drawImage(img, 0, drawY, size, drawH);
                                } else {
                                    const drawW = size * imgAspect;
                                    const drawX = (size - drawW) / 2;
                                    ctx.drawImage(img, drawX, 0, drawW, size);
                                }
                                break;
                            case 'cover':
                                if (imgAspect > 1) {
                                    const drawW = size * imgAspect;
                                    const drawX = (size - drawW) / 2;
                                    ctx.drawImage(img, drawX, 0, drawW, size);
                                } else {
                                    const drawH = size / imgAspect;
                                    const drawY = (size - drawH) / 2;
                                    ctx.drawImage(img, 0, drawY, size, drawH);
                                }
                                break;
                            case 'none':
                                if (imgW > size || imgH > size) {
                                    const sx = (imgW - size) / 2;
                                    const sy = (imgH - size) / 2;
                                    const sWidth = Math.min(size, imgW);
                                    const sHeight = Math.min(size, imgH);
                                    ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, size, size);
                                } else {
                                    const dx = (size - imgW) / 2;
                                    const dy = (size - imgH) / 2;
                                    ctx.drawImage(img, dx, dy, imgW, imgH);
                                }
                                break;
                            default:
                                ctx.drawImage(img, 0, 0, size, size);
                        }

                        const texture = new THREE.CanvasTexture(canvas);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        resolve(texture);
                    };
                    img.onerror = reject;
                    img.src = dataURL;
                });
            }

            async function applyTextureToFace(faceIndex, dataURL, mode) {
                try {
                    const texture = await generateTextureFromImage(dataURL, mode);
                    materials[faceIndex].map = texture;
                    materials[faceIndex].color.setHex(0xffffff);
                    materials[faceIndex].needsUpdate = true;
                    const previewImg = previewImgs[faceIndex];
                    previewImg.src = dataURL;
                    previewImg.style.display = 'block';
                    const previewDiv = previewImg.parentElement;
                    previewDiv.style.background = 'transparent';
                } catch (err) {
                    console.error('çº¹ç†ç”Ÿæˆå¤±è´¥', err);
                }
            }

            // æ„å»ºå…­é¢UI
            const facePanel = document.getElementById('facePanel');
            const previewImgs = [];
            const fileInputs = [];

            for (let i = 0; i < 6; i++) {
                const card = document.createElement('div');
                card.className = 'face-card';
                
                const labelDiv = document.createElement('div');
                labelDiv.style.fontWeight = '600';
                labelDiv.style.background = '#202d51';
                labelDiv.style.borderRadius = '20px';
                labelDiv.style.padding = '4px';
                labelDiv.className = 'face-name';
                labelDiv.innerText = i18n[currentLang].faceNames[i];
                card.appendChild(labelDiv);

                const previewDiv = document.createElement('div');
                previewDiv.className = 'face-preview';
                previewDiv.style.background = '#' + initColors[i].toString(16).padStart(6, '0');
                const previewImg = document.createElement('img');
                previewImg.alt = '';
                previewDiv.appendChild(previewImg);
                card.appendChild(previewDiv);
                previewImgs[i] = previewImg;

                const uploadBtn = document.createElement('button');
                uploadBtn.className = 'btn-upload';
                uploadBtn.setAttribute('data-i18n', 'upload');
                uploadBtn.innerText = i18n[currentLang].upload;
                const clearBtn = document.createElement('button');
                clearBtn.className = 'btn-clear';
                clearBtn.setAttribute('data-i18n', 'clear');
                clearBtn.innerText = i18n[currentLang].clear;

                card.appendChild(uploadBtn);
                card.appendChild(clearBtn);
                facePanel.appendChild(card);

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.className = 'hidden-input';
                document.body.appendChild(fileInput);
                fileInputs.push(fileInput);

                uploadBtn.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const dataUrl = ev.target.result;
                        faceOriginalDataURLs[i] = dataUrl;
                        const mode = getCurrentTextureMode();
                        await applyTextureToFace(i, dataUrl, mode);
                        previewImg.src = dataUrl;
                        previewImg.style.display = 'block';
                        previewDiv.style.background = 'transparent';
                    };
                    reader.readAsDataURL(file);
                    fileInput.value = '';
                });

                clearBtn.addEventListener('click', () => {
                    materials[i].map = null;
                    materials[i].color.setHex(initColors[i]);
                    previewImg.src = '';
                    previewImg.style.display = 'none';
                    previewDiv.style.background = '#' + initColors[i].toString(16).padStart(6, '0');
                    faceOriginalDataURLs[i] = null;
                });
            }

            document.getElementById('oneClickUploadBtn').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        const dataUrl = event.target.result;
                        const mode = getCurrentTextureMode();
                        for (let i = 0; i < 6; i++) {
                            faceOriginalDataURLs[i] = dataUrl;
                            await applyTextureToFace(i, dataUrl, mode);
                            previewImgs[i].src = dataUrl;
                            previewImgs[i].style.display = 'block';
                            const previewDiv = previewImgs[i].parentElement;
                            previewDiv.style.background = 'transparent';
                        }
                    };
                    reader.readAsDataURL(file);
                };
                input.click();
            });

            textureModeSelect.addEventListener('change', async () => {
                const newMode = getCurrentTextureMode();
                for (let i = 0; i < 6; i++) {
                    if (faceOriginalDataURLs[i]) {
                        await applyTextureToFace(i, faceOriginalDataURLs[i], newMode);
                    }
                }
            });

            // --- å½•åˆ¶å‡½æ•° (ä¿ç•™åŸæœ‰ WebM/MP4/æœ¬åœ°GIF) ---
            function getRecorderOptions() {
                const fps = parseInt(document.getElementById('fpsInput').value, 10) || 24;
                const duration = parseFloat(document.getElementById('durationInput').value) || 5;
                return { fps, duration };
            }

            async function startRecording(desiredType = 'webm') {
                const { fps, duration } = getRecorderOptions();
                if (canvas.width === 0 || canvas.height === 0) {
                    alert('Canvaså°ºå¯¸ä¸º0ï¼Œæ— æ³•å½•åˆ¶');
                    return;
                }
                const stream = canvas.captureStream(fps);
                
                let mimeType;
                let fileExt;
                if (desiredType === 'mp4') {
                    if (MediaRecorder.isTypeSupported('video/mp4')) {
                        mimeType = 'video/mp4';
                        fileExt = 'mp4';
                    } else if (MediaRecorder.isTypeSupported('video/mp4; codecs="avc1"')) {
                        mimeType = 'video/mp4; codecs="avc1"';
                        fileExt = 'mp4';
                    } else {
                        console.warn('MP4 not supported, falling back to WebM with .mp4 extension');
                        mimeType = 'video/webm;codecs=vp9';
                        fileExt = 'mp4';
                    }
                } else {
                    mimeType = 'video/webm;codecs=vp9';
                    fileExt = 'webm';
                }

                const recorder = new MediaRecorder(stream, { mimeType });
                const chunks = [];
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `cube_${Date.now()}.${fileExt}`;
                    a.click();
                    URL.revokeObjectURL(url);
                };
                recorder.start();
                setTimeout(() => recorder.stop(), duration * 1000);
            }

            function startGifRecording() {
                const { fps, duration } = getRecorderOptions();
                if (canvas.width === 0 || canvas.height === 0) {
                    alert('Canvaså°ºå¯¸ä¸º0ï¼Œæ— æ³•å½•åˆ¶GIF');
                    return;
                }
                const gifFps = Math.min(fps, 24);
                const totalFrames = Math.floor(gifFps * duration);
                if (totalFrames <= 0) return;

                const btn = document.getElementById('recordGifBtn');
                const originalText = btn.innerText;
                btn.style.opacity = '0.6';
                btn.style.pointerEvents = 'none';
                btn.innerText = `â³ GIF åˆå§‹åŒ–...`;

                const workerScripts = [
                    '/gif.worker.js'
                ];

                let currentWorkerIndex = 0;
                let gif = null;
                let interval = null;
                let captured = 0;

                function createGIF(workerIndex) {
                    if (workerIndex >= workerScripts.length) {
                        throw new Error('æ‰€æœ‰ worker CDN å‡ä¸å¯ç”¨');
                    }
                    return new GIF({
                        workers: 2,
                        quality: 10,
                        width: canvas.width,
                        height: canvas.height,
                        workerScript: workerScripts[workerIndex]
                    });
                }

                try {
                    gif = createGIF(0);
                } catch (e) {
                    console.error('GIF åˆå§‹åŒ–å¤±è´¥:', e);
                    alert('GIF åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°é‡è¯•');
                    resetButton();
                    return;
                }

                function resetButton() {
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                    btn.innerText = originalText;
                }

                gif.on('error', (err) => {
                    console.error('GIF é”™è¯¯:', err);
                    if (currentWorkerIndex < workerScripts.length - 1) {
                        currentWorkerIndex++;
                        try {
                            const newGif = createGIF(currentWorkerIndex);
                            newGif.on('error', gif.errorListeners[0]);
                            newGif.on('finished', gif.finishedListeners[0]);
                            gif = newGif;
                            console.log(`åˆ‡æ¢åˆ° worker: ${workerScripts[currentWorkerIndex]}`);
                        } catch (e) {
                            alert('æ‰€æœ‰ worker å‡ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                            clearInterval(interval);
                            resetButton();
                        }
                    } else {
                        alert('GIF å½•åˆ¶å¤±è´¥: æ‰€æœ‰ worker å‡ä¸å¯ç”¨');
                        clearInterval(interval);
                        resetButton();
                    }
                });

                gif.on('finished', blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `cube_${Date.now()}.gif`;
                    a.click();
                    URL.revokeObjectURL(url);
                    resetButton();
                });

                interval = setInterval(() => {
                    try {
                        gif.addFrame(canvas, { copy: true, delay: 1000 / gifFps });
                        captured++;
                        btn.innerText = `â³ GIF ${captured}/${totalFrames}`;
                        if (captured >= totalFrames) {
                            clearInterval(interval);
                            gif.render();
                        }
                    } catch (e) {
                        console.error('æ·»åŠ å¸§å¤±è´¥:', e);
                        alert('æ·»åŠ å¸§å¤±è´¥ï¼Œå¯èƒ½ canvas ä¸Šä¸‹æ–‡ä¸¢å¤±');
                        clearInterval(interval);
                        resetButton();
                    }
                }, 1000 / gifFps);
            }

            // --- æ–°å¢ï¼šConvertHub GIF å½•åˆ¶ (é€šè¿‡ Serverless ä»£ç†) ---
            async function startGifConvertHub() {
                const apiKey = document.getElementById('convertHubApiKey').value.trim();
                if (!apiKey) {
                    alert(currentLang === 'zh' ? 'è¯·è¾“å…¥ ConvertHub API Key' : 'Please enter your ConvertHub API Key');
                    return;
                }

                const { fps, duration } = getRecorderOptions();
                if (canvas.width === 0 || canvas.height === 0) {
                    alert('Canvaså°ºå¯¸ä¸º0ï¼Œæ— æ³•å½•åˆ¶');
                    return;
                }

                const stream = canvas.captureStream(fps);
                const mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                const chunks = [];
                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const webmBlob = new Blob(chunks, { type: 'video/webm' });
                    const formData = new FormData();
                    formData.append('file', webmBlob, 'recording.webm');
                    formData.append('target_format', 'gif');
                    // å°† API Key æ”¾åœ¨è¯·æ±‚å¤´ä¸­ä¼ é€’ç»™ Serverless å‡½æ•°ï¼ˆæˆ–é€šè¿‡å…¶ä»–å®‰å…¨æ–¹å¼ï¼‰
                    try {
                        const response = await fetch('/api/convert', {
                            method: 'POST',
                            headers: { 'X-API-Key': apiKey }, // é€šè¿‡è‡ªå®šä¹‰å¤´ä¼ é€’
                            body: formData
                        });
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const gifBlob = await response.blob();
                        const url = URL.createObjectURL(gifBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `cube_${Date.now()}.gif`;
                        a.click();
                        URL.revokeObjectURL(url);
                    } catch (err) {
                        console.error('ConvertHub è½¬æ¢å¤±è´¥:', err);
                        alert('è½¬æ¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥ API Key å’Œç½‘ç»œï¼Œæˆ–å°è¯•æœ¬åœ° GIF æŒ‰é’®ã€‚');
                    }
                };
                mediaRecorder.start();
                setTimeout(() => mediaRecorder.stop(), duration * 1000);
            }

            // ç»‘å®šæŒ‰é’®
            document.getElementById('recordWebmBtn').addEventListener('click', () => startRecording('webm'));
            document.getElementById('recordMp4Btn').addEventListener('click', () => startRecording('mp4'));
            document.getElementById('recordGifBtn').addEventListener('click', startGifRecording);
            document.getElementById('recordGifConvertHub').addEventListener('click', startGifConvertHub);

            // è¯­è¨€åˆ‡æ¢äº‹ä»¶
            document.getElementById('langZhBtn').addEventListener('click', () => setLanguage('zh'));
            document.getElementById('langEnBtn').addEventListener('click', () => setLanguage('en'));

            // IPæ£€æµ‹
            fetch('https://ipapi.co/json/')
                .then(res => res.json())
                .then(data => {
                    if (data.country_code === 'CN') {
                        setLanguage('zh');
                    } else {
                        setLanguage('en');
                    }
                })
                .catch(() => {
                    const browserLang = navigator.language || navigator.userLanguage;
                    setLanguage(browserLang.startsWith('zh') ? 'zh' : 'en');
                });
        })();
    </script>
</body>
</html>
